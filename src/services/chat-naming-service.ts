// Chat Naming Service with Auto-naming and Manual Editing
import { getEnhancedAIEngine } from './enhanced-ai-engine'
import { getSupabaseServer } from '@/lib/supabase-server'

export interface ChatNameUpdate {
  conversationId: string
  newName: string
  isAutoGenerated: boolean
}

export interface ConversationWithName {
  id: string
  title: string
  isAutoGenerated: boolean
  lastMessage: string
  updatedAt: string
  messageCount: number
}

export class ChatNamingService {
  
  // Auto-generate chat name based on conversation content
  static async autoGenerateChatName(conversationId: string): Promise<string | null> {
    try {
      const supabase = await getSupabaseServer()
      if (!supabase) return null

      // Get first few messages from the conversation
      const { data: messages } = await supabase
        .from('messages')
        .select('role, content')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: true })
        .limit(5)

      if (!messages || messages.length === 0) {
        return null
      }

      const aiEngine = getEnhancedAIEngine()
      if (!aiEngine) {
        return this.generateFallbackName(messages)
      }

      const namingResult = await aiEngine.generateChatName(messages)
      
      // Update conversation with auto-generated name
      await supabase
        .from('conversations')
        .update({ 
          title: namingResult.suggestedName,
          is_auto_generated: true,
          naming_confidence: namingResult.confidence
        })
        .eq('id', conversationId)

      return namingResult.suggestedName
    } catch (error) {
      console.error('Auto-naming error:', error)
      return null
    }
  }

  // Manually update chat name
  static async updateChatName(conversationId: string, newName: string, userId: string): Promise<boolean> {
    try {
      const supabase = await getSupabaseServer()
      if (!supabase) return false

      // Validate that user owns this conversation
      const { data: conversation } = await supabase
        .from('conversations')
        .select('user_id')
        .eq('id', conversationId)
        .single()

      if (!conversation || conversation.user_id !== userId) {
        throw new Error('Unauthorized: User does not own this conversation')
      }

      // Update conversation name
      const { error } = await supabase
        .from('conversations')
        .update({ 
          title: newName.trim(),
          is_auto_generated: false,
          updated_at: new Date().toISOString()
        })
        .eq('id', conversationId)

      if (error) throw error

      return true
    } catch (error) {
      console.error('Manual naming error:', error)
      return false
    }
  }

  // Get all conversations with enhanced metadata
  static async getConversationsWithNames(userId: string): Promise<ConversationWithName[]> {
    try {
      const supabase = await getSupabaseServer()
      if (!supabase) return []

      const { data: conversations } = await supabase
        .from('conversations')
        .select(`
          id,
          title,
          is_auto_generated,
          updated_at,
          messages (
            content,
            created_at
          )
        `)
        .eq('user_id', userId)
        .order('updated_at', { ascending: false })

      if (!conversations) return []

      return conversations.map(conv => ({
        id: conv.id,
        title: conv.title || 'New Chat',
        isAutoGenerated: conv.is_auto_generated || false,
        lastMessage: conv.messages?.[conv.messages.length - 1]?.content?.substring(0, 100) || '',
        updatedAt: conv.updated_at,
        messageCount: conv.messages?.length || 0
      }))
    } catch (error) {
      console.error('Get conversations error:', error)
      return []
    }
  }

  // Check if conversation needs auto-naming
  static async checkAndAutoName(conversationId: string): Promise<void> {
    try {
      const supabase = await getSupabaseServer()
      if (!supabase) return

      // Check if conversation already has a name
      const { data: conversation } = await supabase
        .from('conversations')
        .select('title, is_auto_generated')
        .eq('id', conversationId)
        .single()

      if (!conversation) return

      // Auto-name if no title exists or if it's a default title
      const needsNaming = !conversation.title || 
                         conversation.title === 'New Chat' || 
                         conversation.title.startsWith('Chat ')

      if (needsNaming) {
        // Check if we have enough messages (at least 2 exchanges)
        const { data: messages } = await supabase
          .from('messages')
          .select('id')
          .eq('conversation_id', conversationId)

        if (messages && messages.length >= 3) {
          await this.autoGenerateChatName(conversationId)
        }
      }
    } catch (error) {
      console.error('Auto-naming check error:', error)
    }
  }

  // Generate fallback name when AI is not available
  private static generateFallbackName(messages: Array<{role: string, content: string}>): string {
    const userMessage = messages.find(m => m.role === 'user')?.content || ''
    
    // Extract key oceanographic terms
    const oceanTerms = [
      'argo', 'temperature', 'salinity', 'current', 'ocean', 'marine', 
      'coastal', 'sea', 'water', 'climate', 'research', 'analysis'
    ]
    
    const words = userMessage.toLowerCase().split(/\s+/)
    const relevantTerms = words.filter(word => 
      oceanTerms.some(term => word.includes(term))
    )
    
    if (relevantTerms.length > 0) {
      const capitalizedTerms = relevantTerms.slice(0, 3).map(term => 
        term.charAt(0).toUpperCase() + term.slice(1)
      )
      return `${capitalizedTerms.join(' ')} Discussion`
    }
    
    // Fallback to date-based name
    return `Ocean Research ${new Date().toLocaleDateString()}`
  }

  // Validate chat name
  static validateChatName(name: string): {isValid: boolean, error?: string} {
    const trimmedName = name.trim()
    
    if (!trimmedName) {
      return { isValid: false, error: 'Chat name cannot be empty' }
    }
    
    if (trimmedName.length > 100) {
      return { isValid: false, error: 'Chat name must be less than 100 characters' }
    }
    
    if (trimmedName.length < 3) {
      return { isValid: false, error: 'Chat name must be at least 3 characters' }
    }
    
    // Check for inappropriate content (basic check)
    const inappropriatePatterns = [
      /fuck/i, /shit/i, /damn/i, /hell/i
    ]
    
    if (inappropriatePatterns.some(pattern => pattern.test(trimmedName))) {
      return { isValid: false, error: 'Chat name contains inappropriate content' }
    }
    
    return { isValid: true }
  }

  // Get naming suggestions based on content
  static generateNamingSuggestions(content: string): string[] {
    const suggestions = []
    const lowerContent = content.toLowerCase()
    
    // Location-based suggestions
    if (lowerContent.includes('mumbai')) {
      suggestions.push('Mumbai Ocean Analysis')
    }
    if (lowerContent.includes('bengal')) {
      suggestions.push('Bay of Bengal Study')
    }
    if (lowerContent.includes('arabian')) {
      suggestions.push('Arabian Sea Research')
    }
    
    // Parameter-based suggestions
    if (lowerContent.includes('temperature')) {
      suggestions.push('Temperature Profile Analysis')
    }
    if (lowerContent.includes('salinity')) {
      suggestions.push('Salinity Distribution Study')
    }
    if (lowerContent.includes('current')) {
      suggestions.push('Ocean Current Investigation')
    }
    
    // Data source suggestions
    if (lowerContent.includes('argo')) {
      suggestions.push('ARGO Float Data Analysis')
    }
    if (lowerContent.includes('satellite')) {
      suggestions.push('Satellite Ocean Observations')
    }
    
    // Generic suggestions
    suggestions.push('Ocean Research Chat')
    suggestions.push('Marine Science Discussion')
    suggestions.push('Oceanographic Analysis')
    
    return [...new Set(suggestions)].slice(0, 5)
  }
}

// ChatNamingService is already exported above
